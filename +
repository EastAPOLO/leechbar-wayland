pub fn start_xorg_panel(bar_img_in: Receiver<(File, i32)>,
                        resize_out: Sender<u32>,
                        mouse_out: Sender<MouseEvent>)
                        -> Result<(), Box<Error>> {
    let (connection, screen) = xcb::Connection::connect(None)?;
    let connection = ewmh::Connection::connect(connection).map_err(|(e, _)| e)?;
    let screen = connection.get_setup().roots().nth(screen as usize)?;

    let (w, h) = (100, 10);

    let x = matches.value_of("x").map_or(0, |n| n.parse::<i16>().unwrap());
    let y = matches.value_of("y").map_or(0, |n| n.parse::<i16>().unwrap());

    let wid = connection.generate_id();
    xcb::create_window(&connection,
                       xcb::COPY_FROM_PARENT as u8,
                       wid,
                       screen.root(),
                       x,
                       y,
                       w,
                       h,
                       10, // border_width
                       xcb::WINDOW_CLASS_INPUT_OUTPUT as u16,
                       screen.root_visual(),
                       &[(xcb::CW_BACKING_PIXEL, screen.black_pixel())]);

    icccm::set_wm_class(&connection, wid, "crowbar", "Bar");
    icccm::set_wm_name(&connection, wid, "crowbar");
    ewmh::set_wm_name(&connection, wid, "crowbar");
    ewmh::set_wm_state(&connection,
                       wid,
                       &[connection.WM_STATE_STICKY(), connection.WM_STATE_ABOVE()]);
    ewmh::set_wm_window_type(&connection, wid, &[connection.WM_WINDOW_TYPE_DOCK()]);

    xcb::map_window(&connection, wid);
    connection.flush();

    loop {}
}
